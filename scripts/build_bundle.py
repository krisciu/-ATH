#!/usr/bin/env python3
"""
Build a single-file executable archive for ~ATH.

The resulting artifact is a Python zipapp that already contains all third-party
dependencies. Users only need a Python 3.9+ runtime on their machine.

Usage:
    python scripts/build_bundle.py

Optional flags:
    --api-key-file path/to/key.txt   # Injects key into generated launch wrapper
    --output-name NAME               # Change the name of the produced launcher

Outputs:
    dist/tildeath.pyz                # Executable zipapp
    dist/install_stub.sh             # One-line installer template
    dist/README.txt                  # Distribution notes for the bundle
"""

from __future__ import annotations

import argparse
import shutil
import subprocess
import sys
import textwrap
import shlex
from pathlib import Path


PROJECT_ROOT = Path(__file__).resolve().parents[1]
BUILD_ROOT = PROJECT_ROOT / ".build" / "zipapp"
APP_ROOT = BUILD_ROOT / "app"
DIST_ROOT = PROJECT_ROOT / "dist"

SOURCE_DIRS = [
    "engine",
    "config",
]

SOURCE_FILES = [
    "main.py",
    "test_visuals.py",
    "README.md",
    "QUICKSTART.md",
    "PROJECT_SUMMARY.md",
]


def run(cmd: list[str], cwd: Path | None = None) -> None:
    """Run a subprocess, surfacing errors."""
    subprocess.run(cmd, cwd=cwd, check=True)


def clean_previous_build() -> None:
    """Remove previous build artifacts."""
    if BUILD_ROOT.exists():
        shutil.rmtree(BUILD_ROOT)
    BUILD_ROOT.mkdir(parents=True)
    APP_ROOT.mkdir()
    DIST_ROOT.mkdir(exist_ok=True)


def install_dependencies(target: Path) -> None:
    """Install Python dependencies into the bundle staging directory."""
    requirements = PROJECT_ROOT / "requirements.txt"
    if not requirements.exists():
        raise FileNotFoundError("requirements.txt is missing.")

    run(
        [
            sys.executable,
            "-m",
            "pip",
            "install",
            "--upgrade",
            "--target",
            str(target),
            "-r",
            str(requirements),
        ]
    )


def copy_project_sources(target: Path) -> None:
    """Copy application sources into staging area."""
    for folder in SOURCE_DIRS:
        src = PROJECT_ROOT / folder
        dst = target / folder
        if dst.exists():
            shutil.rmtree(dst)
        shutil.copytree(src, dst)

    for filename in SOURCE_FILES:
        src = PROJECT_ROOT / filename
        if src.exists():
            shutil.copy2(src, target / src.name)


def write_entrypoint(target: Path) -> None:
    """Create __main__.py so the archive can be executed directly."""
    entrypoint = textwrap.dedent(
        """\
        # Auto-generated by scripts/build_bundle.py
        from main import main


        if __name__ == "__main__":
            main()
        """
    )
    (target / "__main__.py").write_text(entrypoint, encoding="utf-8")


def build_zipapp(source: Path, destination: Path) -> None:
    """Create the final zipapp executable."""
    run(
        [
            sys.executable,
            "-m",
            "zipapp",
            str(source),
            "-o",
            str(destination),
            "-p",
            "/usr/bin/env python3",
        ]
    )
    destination.chmod(0o755)


def write_install_stub(
    artifact_name: str,
    api_key: str | None,
) -> None:
    """Generate installer stub and distribution notes."""
    zipapp_url_placeholder = "<PUT_DOWNLOAD_URL_HERE>"
    default_install_path = "${HOME}/.ATH"
    default_key_line = (
        f"DEFAULT_SHARED_KEY={shlex.quote(api_key)}" if api_key else "DEFAULT_SHARED_KEY=''"
    )

    stub_contents = textwrap.dedent(
        f"""\
        #!/usr/bin/env bash
        #
        # Installer for ~ATH. Replace {zipapp_url_placeholder} with the hosted bundle URL.
        #
        set -euo pipefail

        ZIPAPP_URL="{zipapp_url_placeholder}"
        INSTALL_PATH="{default_install_path}"
        CACHE_DIR="${{HOME}}/.cache/tildeath"

        mkdir -p "$(dirname "$INSTALL_PATH")"
        mkdir -p "$CACHE_DIR"

        tmp_zip="$CACHE_DIR/{artifact_name}"

        echo "Downloading ~ATH..."
        curl -fsSL "$ZIPAPP_URL" -o "$tmp_zip"
        chmod +x "$tmp_zip"

        cat > "$INSTALL_PATH" <<'LAUNCHER'
        #!/usr/bin/env bash
        set -euo pipefail

        export ATH_HOME="${{ATH_HOME:-$HOME/.tildeath}}"
        mkdir -p "$ATH_HOME"
        CONFIG_FILE="$ATH_HOME/.env"
        ZIPAPP_PATH="$HOME/.cache/tildeath/{artifact_name}"
        {default_key_line}

        if [ "${{1:-}}" = "--configure" ]; then
            echo "Configure Anthropic API key for ~ATH"
            read -r -s -p "Enter ANTHROPIC_API_KEY (leave empty to clear): " new_key
            echo
            if [ -n "$new_key" ]; then
                printf 'ANTHROPIC_API_KEY=%s\n' "$new_key" > "$CONFIG_FILE"
                echo "Saved to $CONFIG_FILE"
            else:
                rm -f "$CONFIG_FILE"
                echo "Cleared stored key."
            fi
            exit 0
        fi

        if [ -n "${{ANTHROPIC_API_KEY:-}}" ]; then
            :
        elif [ -f "$CONFIG_FILE" ]; then
            set -a
            . "$CONFIG_FILE"
            set +a
        elif [ -n "$DEFAULT_SHARED_KEY" ]; then
            export ANTHROPIC_API_KEY="$DEFAULT_SHARED_KEY"
        fi

        if [ -z "${{ANTHROPIC_API_KEY:-}}" ]; then
            cat <<'EOF' >&2
Missing ANTHROPIC_API_KEY.

Provide one with:
  1. ~/.ATH --configure
  2. export ANTHROPIC_API_KEY=your_key_here
  3. Editing $CONFIG_FILE manually
EOF
            exit 1
        fi

        cd "$ATH_HOME"
        exec "$ZIPAPP_PATH" "$@"
        LAUNCHER

        chmod +x "$INSTALL_PATH"

        echo "Installed ~ATH launcher at $INSTALL_PATH"
        echo "Run it with: $INSTALL_PATH"
        """
    )

    installer_path = DIST_ROOT / "install_stub.sh"
    installer_path.write_text(stub_contents, encoding="utf-8")
    installer_path.chmod(0o755)

    readme_text = textwrap.dedent(
        f"""\
        ~ATH Distribution Bundle
        ========================

        Files:
          - {artifact_name}    -> Executable zipapp (Python 3.9+ required)
          - install_stub.sh    -> Template installer script

        Recommended release workflow:
          1. Host {artifact_name} somewhere with HTTPS access (S3, GitHub release, etc.).
          2. Edit install_stub.sh, replacing the placeholder URL with the hosted file.
          3. (Optional) Put the Anthropic key into the launcher section if you want to share one.
          4. Share the one-liner installer:
               curl -fsSL <your-install-script-url> | bash

        After install, users can launch the game with:
            ~/.ATH

        Users can swap keys any time:
            ~/.ATH --configure   # prompts for a new key
        or by exporting ANTHROPIC_API_KEY before running the launcher.

        The launcher stores runtime artifacts in $HOME/.tildeath and reuses the cached zipapp.
        """
    )
    (DIST_ROOT / "README.txt").write_text(readme_text, encoding="utf-8")


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Build ~ATH distributable bundle.")
    parser.add_argument(
        "--api-key-file",
        type=Path,
        help="Optional file containing an Anthropic API key to embed into the launcher stub.",
    )
    parser.add_argument(
        "--output-name",
        default="tildeath.pyz",
        help="Name of the generated zipapp artifact (default: tildeath.pyz).",
    )
    return parser.parse_args()


def main() -> None:
    args = parse_args()

    api_key = None
    if args.api_key_file:
        if not args.api_key_file.exists():
            raise FileNotFoundError(f"API key file not found: {args.api_key_file}")
        api_key = args.api_key_file.read_text(encoding="utf-8").strip()

    clean_previous_build()
    install_dependencies(APP_ROOT)
    copy_project_sources(APP_ROOT)
    write_entrypoint(APP_ROOT)

    artifact_path = DIST_ROOT / args.output_name
    build_zipapp(APP_ROOT, artifact_path)

    write_install_stub(args.output_name, api_key)

    print(f"Bundle built at: {artifact_path}")
    print(f"Installer template: {DIST_ROOT / 'install_stub.sh'}")


if __name__ == "__main__":
    main()
